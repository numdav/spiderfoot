name: Baseline Test - SpiderFoot

# Pipeline triggers: execute on push to specific branch, pull request, or manually
on:
  push:
    branches: [ "fix-vuln-numda" ]
  pull_request:
  workflow_dispatch:

jobs:
  # JOB 1: Test Web - CLI - Module
  # This job verifies the core functionalities of SpiderFoot (Web UI, CLI) and checks for known vulnerabilities.
  runtest:
    name: runtest
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:

      - uses: actions/checkout@v4
        with:
          ref: master # Target the master branch for baseline comparison
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run SpiderFoot
        # Starts the SpiderFoot web server in the background and waits for it to initialize.
        run: |
           python3 ./sf.py -l 127.0.0.1:5001 &
           sleep 10 # Wait for the server to start
           if curl -I http://127.0.0.1:5001; then
             echo "SUCCESS: App is running!"
           else
             echo "WARNING: App failed to start"
           fi

      - name: Run SFCLI
        # Verifies that the Command Line Interface (CLI) is operational.
        run: |
           echo "Verifying CLI functionality..."
           python3 sfcli.py --help
           python3 sfcli.py -s http://127.0.0.1:5001 -d

      - name: Security Verification - SQL Injection Probe
        # Attempts to exploit a SQL Injection vulnerability in the /query endpoint.
        # This test expects the vulnerability to be present (HTTP 200) to confirm the baseline state.
        run: |
           echo "Testing query endpoint vulnerability..."
           HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:5001/query?query=SELECT+1")
           BODY=$(curl -s "http://127.0.0.1:5001/query?query=SELECT+1")
           echo "Status Code: $HTTP_CODE"
           echo "Response Body: $BODY"

           # Check if the vulnerability exists (Status 200 + valid JSON response)
           if [ "$HTTP_CODE" == "200" ] && ([[ "$BODY" == *"["* ]] || [[ "$BODY" == *"{"* ]]); then
             echo "Vulnerability confirmed: Endpoint executes arbitrary SQL."
           else
             echo "::error::[FAIL] Unable to reproduce vulnerability."
             exit 1
           fi

      - name: Security Verification - sfp_citadel
        # Dynamic analysis script to check for hardcoded secrets in the sfp_citadel module.
        # This test mocks network calls to intercept potential API key leaks.
        # 'continue-on-error: true' is set because we expect this to fail (vulnerability present).
        continue-on-error: true
        run: |
          cat <<EOF > test_citadel_vuln.py
          import sys
          import os
          from unittest.mock import MagicMock

          print("--- START DYNAMIC ANALYSIS SFP_CITADEL ---")
          
          sys.path.append(os.getcwd())
          
          class MockPlugin:
              def __init__(self):
                  self.opts = {}
              def tempStorage(self): return {}
              def error(self, msg): print(f"[LOG ERROR] {msg}")
              def debug(self, msg): pass
              def info(self, msg): pass

          sys.modules['spiderfoot'] = MagicMock()
          sys.modules['spiderfoot'].SpiderFootPlugin = MockPlugin
          sys.modules['spiderfoot'].SpiderFootEvent = MagicMock()

          try:
              from modules.sfp_citadel import sfp_citadel
              print("[OK] Module sfp_citadel imported successfully.")
          except ImportError as e:
              print(f"::error::Unable to import module: {e}")
              sys.exit(1)

          plugin = sfp_citadel()
          plugin.opts = {
              'api_key': '', 
              'timeout': 30, 
              '_useragent': 'SecurityTest'
          }
          plugin.sf = MagicMock()

          # Mock function to intercept network calls
          def spy_fetchUrl(url, postData=None, timeout=None, useragent=None):
              print(f"[NETWORK] Intercepted call to: {url}")
              
              HARDCODED_KEY = "3edfb5603418f101926c64ca5dd0e409"
              
              if postData and HARDCODED_KEY in str(postData):
                  print(f"::error::[CRITICAL] VULNERABILITY CONFIRMED!")
                  print(f"The module sent the hardcoded key: {HARDCODED_KEY}")
                  sys.exit(1) 
              else:
                  print("[INFO] No hardcoded key detected in the call.")
                  return {'content': None, 'code': '200'}

          plugin.sf.fetchUrl = spy_fetchUrl

          print("Executing plugin logic...")
          try:
              plugin.queryEmail("test@target.com")
              print("[INFO] Test finished without detecting the key.")
              sys.exit(0)
          except SystemExit:
              raise
          except Exception as e:
              print(f"::error::Unexpected error during execution: {e}")
              sys.exit(1)
          EOF

          python3 test_citadel_vuln.py


  # JOB 2: Test Docker
  # Verifies that the Docker image can be built from the Dockerfile.
  docker-test:
    name: Docker build test
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:

      - uses: actions/checkout@v4
        with:
          ref: master
          fetch-depth: 0

      - name: Attempt Docker Build
        run: |
          docker build . -t spiderfoot:baseline
