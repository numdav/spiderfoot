name: Functional Tests - SpiderFoot

# Pipeline triggers: execute on push to specific branch, pull request, or manually
on:
  push:
    branches: [ "fix-vuln-numda", "master", "main" ]
  pull_request:
  workflow_dispatch:

jobs:
  # JOB 1: Test Web - CLI - Module
  # This job verifies the core functionalities of SpiderFoot (Web UI, CLI) and checks for known vulnerabilities.
  runtest:
    name: runtest
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run SpiderFoot
        # Starts the SpiderFoot web server in the background and checks if it's reachable.
        run: |
           python3 ./sf.py -l 127.0.0.1:5001 &
           sleep 10 # Wait for the server to start
           curl --fail http://127.0.0.1:5001

      - name: Run SFCLI
        # Verifies that the Command Line Interface (CLI) is operational.
        run: |
           echo "Verifying CLI functionality..."
           python3 sfcli.py --help
           python3 sfcli.py -s http://127.0.0.1:5001 -d

      - name: Verify Core Functionality (Regression Test)
        # Verifies that the database is accessible via legitimate API calls.
        run: |
           echo "Testing /scanlist API..."
           RESPONSE=$(curl -s "http://127.0.0.1:5001/scanlist")
           
           # If the response contains a JSON list (square bracket), the app is working.
           if [[ "$RESPONSE" == *"["* ]]; then
             echo "[SUCCESS] API /scanlist working. DB connected."
           else
             echo "[FAIL] API /scanlist did not return valid data. Possible regression!"
             echo "Output received: $RESPONSE"
             exit 1
           fi

      - name: Verify SQL Injection Fix
        # Verifies that the vulnerable endpoint is now blocked (HTTP 403 Forbidden).
        run: |
           echo "Testing SQL Injection blocking..."
           HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:5001/query?query=SELECT+1")
           
           if [ "$HTTP_CODE" == "403" ]; then
             echo "[SUCCESS] Fix verified: Attack blocked (HTTP 403 Forbidden)."
           elif [ "$HTTP_CODE" == "200" ]; then
             echo "[FAIL] Vulnerability still present! Query executed (HTTP 200)."
             exit 1
           else
             echo "[INFO] Unexpected but safe response code: $HTTP_CODE"
           fi

      - name: Security Verification - sfp_citadel
        # This test ensures that the hardcoded key is NOT sent. It should SUCCEED if the fix is working.
        run: |
          cat <<EOF > test_citadel_vuln.py
          import sys
          import os
          from unittest.mock import MagicMock

          print("--- START DYNAMIC ANALYSIS SFP_CITADEL ---")

          sys.path.append(os.getcwd())

          class MockPlugin:
              def __init__(self):
                  self.opts = {}
              def tempStorage(self): return {}
              def error(self, msg): print(f"[LOG ERROR] {msg}")
              def debug(self, msg): pass
              def info(self, msg): pass

          sys.modules['spiderfoot'] = MagicMock()
          sys.modules['spiderfoot'].SpiderFootPlugin = MockPlugin
          sys.modules['spiderfoot'].SpiderFootEvent = MagicMock()

          try:
              from modules.sfp_citadel import sfp_citadel
              print("[OK] Module sfp_citadel imported successfully.")
          except ImportError as e:
              print(f"::error::Unable to import module: {e}")
              sys.exit(1)

          plugin = sfp_citadel()
          plugin.opts = {
              'api_key': '', 
              'timeout': 30, 
              '_useragent': 'SecurityTest'
          }
          plugin.sf = MagicMock()

          # Mock function to intercept network calls
          def spy_fetchUrl(url, postData=None, timeout=None, useragent=None):
              print(f"[NETWORK] Intercepted call to: {url}")
              
              HARDCODED_KEY = "3edfb5603418f101926c64ca5dd0e409"
              
              if postData and HARDCODED_KEY in str(postData):
                  print(f"::error::[CRITICAL] VULNERABILITY CONFIRMED!")
                  print(f"The module sent the hardcoded key: {HARDCODED_KEY}")
                  sys.exit(1) 
              else:
                  print("[INFO] No hardcoded key detected in the call.")
                  return {'content': None, 'code': '200'}

          plugin.sf.fetchUrl = spy_fetchUrl

          print("Executing plugin logic...")
          try:
              plugin.queryEmail("test@target.com")
              print("[INFO] Test finished without detecting the key.")
              sys.exit(0)
          except SystemExit:
              raise
          except Exception as e:
              print(f"::error::Unexpected error during execution: {e}")
              sys.exit(1)
          EOF

          python3 test_citadel_vuln.py

  # JOB 2: Test Docker
  # Verifies that the Docker image can be built with the new configuration.
  docker-test:
    name: Docker build test
    runs-on: ubuntu-latest
    needs: runtest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Attempt Docker Build
        run: |
          docker build . -t spiderfoot:funcional
